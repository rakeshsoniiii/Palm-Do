import cv2
import numpy as np
import mediapipe as mp
import os
import pickle
from sklearn.svm import SVC
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import make_pipeline
from collections import defaultdict

class PalmBiometricSystem:
    def __init__(self):
        # Initialize MediaPipe Hands
        self.mp_hands = mp.solutions.hands
        self.hands = self.mp_hands.Hands(
            static_image_mode=False,
            max_num_hands=1,
            min_detection_confidence=0.7,
            min_tracking_confidence=0.5
        )
        self.mp_drawing = mp.solutions.drawing_utils
        
        # Model and data storage
        self.model = None
        self.scan_data = defaultdict(list)
        self.current_user = None

    def scan_palm(self, num_scans=5, user_id="unknown"):
        """Capture multiple palm scans for a user"""
        self.current_user = user_id
        cap = cv2.VideoCapture(0)
        
        print(f"Capturing {num_scans} scans for user: {user_id}")
        print("Position your palm facing the camera, about 30cm away")
        print("Press 'c' to capture, 'q' to finish early")

        scan_count = 0
        previous_frames = []
        
        while scan_count < num_scans:
            ret, frame = cap.read()
            if not ret:
                break
                
            frame = cv2.flip(frame, 1)
            rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            
            # Process with MediaPipe
            results = self.hands.process(rgb_frame)
            
            if results.multi_hand_landmarks:
                for hand_landmarks in results.multi_hand_landmarks:
                    # Draw hand landmarks
                    self.mp_drawing.draw_landmarks(frame, hand_landmarks, self.mp_hands.HAND_CONNECTIONS)
                    
                    # Display instructions
                    cv2.putText(frame, f"Scan {scan_count+1}/{num_scans} - Press 'c'", 
                               (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
            
            cv2.imshow(f"Palm Scanning - User: {user_id}", frame)
            
            key = cv2.waitKey(1) & 0xFF
            if key == ord('c') and results.multi_hand_landmarks:
                # Store the scan
                hand_profile = {
                    "landmarks": results.multi_hand_landmarks[0],
                    "image": frame.copy(),
                    "timestamp": cv2.getTickCount()/cv2.getTickFrequency()
                }
                self.scan_data[user_id].append(hand_profile)
                scan_count += 1
                print(f"Capture {scan_count}/{num_scans} complete")
                
                # Show confirmation
                cv2.imshow("Capture Saved", frame)
                cv2.waitKey(500)
                cv2.destroyWindow("Capture Saved")
                
            elif key == ord('q'):
                break
        
        cap.release()
        cv2.destroyAllWindows()
        print(f"Completed {scan_count} scans for {user_id}")
        return scan_count

    def extract_features(self, landmarks):
        """Convert hand landmarks to feature vector"""
        # Get wrist (point 0) as reference
        wrist = landmarks.landmark[0]
        
        features = []
        # Relative positions of key landmarks
        key_points = [4, 8, 12, 16, 20]  # Fingertips
        for point_idx in key_points:
            point = landmarks.landmark[point_idx]
            features.extend([
                point.x - wrist.x,
                point.y - wrist.y,
                point.z - wrist.z
            ])
        
        # Add palm width/height ratio
        pinky_base = landmarks.landmark[17]
        index_base = landmarks.landmark[5]
        middle_tip = landmarks.landmark[12]
        
        palm_width = abs(pinky_base.x - index_base.x)
        palm_height = abs(middle_tip.y - wrist.y)
        features.append(palm_width / palm_height if palm_height > 0 else 0)
        
        return np.array(features)

    def train_model(self):
        """Train recognition model on collected scans"""
        if not self.scan_data:
            print("No scan data available. Please capture scans first.")
            return False
        
        X = []
        y = []
        
        for user_id, scans in self.scan_data.items():
            for scan in scans:
                features = self.extract_features(scan["landmarks"])
                X.append(features)
                y.append(user_id)
        
        if len(set(y)) < 2:
            print("Need at least 2 different users for training")
            return False
        
        self.model = make_pipeline(
            StandardScaler(),
            SVC(kernel='rbf', probability=True)
        )
        
        # Simple train-test split (for demo - use cross-validation in production)
        from sklearn.model_selection import train_test_split
        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
        
        self.model.fit(X_train, y_train)
        accuracy = self.model.score(X_test, y_test)
        print(f"Model trained with accuracy: {accuracy:.2f}")
        return True

    def recognize_hand(self):
        """Real-time hand recognition"""
        if not self.model:
            print("Model not trained. Please train first.")
            return
            
        cap = cv2.VideoCapture(0)
        
        while True:
            ret, frame = cap.read()
            if not ret:
                break
                
            frame = cv2.flip(frame, 1)
            rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            
            results = self.hands.process(rgb_frame)
            
            if results.multi_hand_landmarks:
                for hand_landmarks in results.multi_hand_landmarks:
                    # Extract features and predict
                    features = self.extract_features(hand_landmarks)
                    user_id = self.model.predict([features])[0]
                    confidence = self.model.predict_proba([features]).max()
                    
                    # Draw results
                    self.mp_drawing.draw_landmarks(
                        frame, hand_landmarks, self.mp_hands.HAND_CONNECTIONS)
                    
                    cv2.putText(frame, f"User: {user_id} ({confidence:.0%})", 
                               (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2)
            
            cv2.imshow("Hand Recognition", frame)
            if cv2.waitKey(1) & 0xFF == ord('q'):
                break
        
        cap.release()
        cv2.destroyAllWindows()

    def save_data(self, filename="palm_data.pkl"):
        """Save scan data and model to file"""
        data = {
            'scan_data': dict(self.scan_data),
            'model': self.model
        }
        with open(filename, 'wb') as f:
            pickle.dump(data, f)
        print(f"Data saved to {filename}")

    def load_data(self, filename="palm_data.pkl"):
        """Load scan data and model from file"""
        if os.path.exists(filename):
            with open(filename, 'rb') as f:
                data = pickle.load(f)
            self.scan_data = defaultdict(list, data['scan_data'])
            self.model = data['model']
            print(f"Loaded data with {len(self.scan_data)} users")
            return True
        print(f"File {filename} not found")
        return False

def main():
    system = PalmBiometricSystem()
    
    while True:
        print("\nPalm Biometric System Menu:")
        print("1. Register New User")
        print("2. Train Recognition Model")
        print("3. Real-time Recognition")
        print("4. Save Data")
        print("5. Load Data")
        print("6. Exit")
        
        choice = input("Select option: ")
        
        if choice == "1":
            user_id = input("Enter user ID: ")
            system.scan_palm(num_scans=5, user_id=user_id)
        elif choice == "2":
            system.train_model()
        elif choice == "3":
            system.recognize_hand()
        elif choice == "4":
            system.save_data()
        elif choice == "5":
            system.load_data()
        elif choice == "6":
            break
        else:
            print("Invalid choice")

if __name__ == "__main__":
    main()
